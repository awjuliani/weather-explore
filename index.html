<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Compare average monthly temperatures, rainfall, and sunlight hours between cities using interactive 3D visualizations. Explore high, low, and mean temperatures, precipitation, or daily sunshine across the year.">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>☀️</text></svg>">
    <title>City Weather Explorer - 3D Climate Comparison</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #f8f9fa;
            --bg-secondary: #ffffff;
            --bg-chart: linear-gradient(180deg, #f0f4f8 0%, #e8eef3 100%);
            --text-primary: #2d3436;
            --text-secondary: #636e72;
            --text-muted: #888;
            --border-color: #e0e0e0;
            --border-light: #ddd;
            --input-bg: #f8f9fa;
            --shadow: rgba(0, 0, 0, 0.06);
            --shadow-strong: rgba(0, 0, 0, 0.1);
            --legend-bg: rgba(255, 255, 255, 0.9);
            --legend-border: rgba(0, 0, 0, 0.1);
        }

        [data-theme="dark"] {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-chart: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --text-muted: #707070;
            --border-color: #2a2a4a;
            --border-light: #3a3a5a;
            --input-bg: #0f0f1a;
            --shadow: rgba(0, 0, 0, 0.3);
            --shadow-strong: rgba(0, 0, 0, 0.4);
            --legend-bg: rgba(22, 33, 62, 0.9);
            --legend-border: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            transition: background 0.3s ease, color 0.3s ease;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
            position: relative;
        }

        h1 {
            font-size: 1.8rem;
            font-weight: 300;
            letter-spacing: 2px;
            margin-bottom: 5px;
            background: linear-gradient(90deg, #e67e22, #27ae60, #9b59b6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            font-size: 0.85rem;
            color: var(--text-secondary);
            font-weight: 300;
        }

        .main-layout {
            display: flex;
            gap: 30px;
            flex: 1;
            min-height: 0;
        }

        .left-panel {
            width: 280px;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .right-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .chart-type-selector {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px 15px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .chart-type-selector label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        .toggle-group {
            display: flex;
            background: var(--input-bg);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            overflow: hidden;
        }

        .toggle-group + .toggle-group {
            margin-top: 10px;
        }

        .toggle-btn {
            flex: 1;
            padding: 10px 8px;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
            border-right: 1px solid var(--border-light);
        }

        .toggle-btn:last-child {
            border-right: none;
        }

        .toggle-btn:hover {
            background: rgba(39, 174, 96, 0.1);
            color: var(--text-primary);
        }

        .toggle-btn.active {
            background: #27ae60;
            color: #fff;
        }

        .toggle-btn.active:hover {
            background: #219a52;
        }

        .controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
            position: relative;
            z-index: 100;
        }

        .city-selector {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 12px 15px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: all 0.3s ease;
            position: relative;
        }

        .city-selector:hover {
            border-color: var(--border-light);
            box-shadow: 0 4px 12px var(--shadow-strong);
        }

        .city-selector label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        .color-indicator {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            margin-right: 8px;
            vertical-align: middle;
        }

        .search-container {
            position: relative;
        }

        .city-input {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }

        .city-input:focus {
            outline: none;
            border-color: #27ae60;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.15);
        }

        .city-input::placeholder {
            color: var(--text-muted);
        }

        .autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            margin-top: 5px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px var(--shadow-strong);
        }

        .autocomplete-dropdown.show {
            display: block;
        }

        .autocomplete-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            transition: background 0.2s ease;
        }

        .autocomplete-item:hover {
            background: rgba(39, 174, 96, 0.15);
        }

        .autocomplete-item:last-child {
            border-bottom: none;
        }

        .autocomplete-item .city-name {
            font-weight: 500;
            color: var(--text-primary);
            font-size: 0.95rem;
        }

        .autocomplete-item .city-details {
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 2px;
        }

        .selected-city {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(230, 126, 34, 0.1);
            border: 1px solid rgba(230, 126, 34, 0.4);
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 8px;
        }

        .selected-city.color-2 {
            background: rgba(39, 174, 96, 0.1);
            border-color: rgba(39, 174, 96, 0.4);
        }

        .selected-city.color-3 {
            background: rgba(155, 89, 182, 0.1);
            border-color: rgba(155, 89, 182, 0.4);
        }

        .selected-city .city-info {
            display: flex;
            flex-direction: column;
        }

        .selected-city .city-info .name {
            font-weight: 500;
            font-size: 0.9rem;
        }

        .selected-city .city-info .country {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .selected-city .remove-btn {
            background: none;
            border: none;
            color: #e74c3c;
            font-size: 1.1rem;
            cursor: pointer;
            padding: 5px;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .selected-city .remove-btn:hover {
            opacity: 1;
        }

        .loading-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .spinner {
            width: 14px;
            height: 14px;
            border: 2px solid var(--border-color);
            border-top-color: #27ae60;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .error-message {
            background: rgba(231, 76, 60, 0.1);
            border: 1px solid rgba(231, 76, 60, 0.3);
            color: #e74c3c;
            padding: 8px 12px;
            border-radius: 8px;
            margin-top: 8px;
            font-size: 0.85rem;
        }

        .decade-selector {
            margin-top: 8px;
        }

        .decade-selector label {
            display: block;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-muted);
            margin-bottom: 4px;
        }

        .decade-select {
            width: 100%;
            background: var(--input-bg);
            border: 1px solid var(--border-light);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .decade-select:focus {
            outline: none;
            border-color: #27ae60;
            box-shadow: 0 0 0 3px rgba(39, 174, 96, 0.15);
        }

        .chart-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .chart-card {
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            box-shadow: 0 2px 8px var(--shadow);
            flex: 1;
            display: none;
            flex-direction: column;
            transition: background 0.3s ease, border-color 0.3s ease;
        }

        .chart-card.active {
            display: flex;
        }

        .chart-wrapper {
            position: relative;
            flex: 1;
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-chart);
            min-height: 400px;
        }

        .legend-container {
            position: absolute;
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row;
            gap: 12px;
            z-index: 10;
        }

        .legend-item {
            display: none;
            align-items: center;
            gap: 6px;
            background: var(--legend-bg);
            padding: 6px 12px;
            border-radius: 6px;
            border: 1px solid var(--legend-border);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
            cursor: pointer;
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .legend-item:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .legend-item.visible {
            display: flex;
        }

        .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
        }

        .legend-text {
            font-size: 0.8rem;
            color: var(--text-primary);
        }

        .chart-wrapper canvas {
            display: block;
        }

        .no-data-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: var(--text-muted);
            font-size: 1rem;
            text-align: center;
        }

        .instructions {
            text-align: center;
            color: var(--text-muted);
            font-size: 0.75rem;
            margin-top: 10px;
        }

        /* Toggles */
        .toggle-row {
            display: flex;
            gap: 10px;
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            padding: 10px 15px;
            box-shadow: 0 2px 8px var(--shadow);
            transition: background 0.3s ease, border-color 0.3s ease;
            white-space: nowrap;
        }

        .theme-toggle span {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: var(--border-color);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: #fff;
            border-radius: 50%;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .toggle-switch.active {
            background: #27ae60;
        }

        .toggle-switch.active::after {
            transform: translateX(24px);
        }

        footer {
            text-align: center;
            padding: 15px;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        footer a {
            color: #27ae60;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }

        .share-btn {
            position: absolute;
            top: 0;
            right: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px 12px;
            box-shadow: 0 2px 8px var(--shadow);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            white-space: nowrap;
        }

        .share-btn:hover {
            border-color: #27ae60;
            color: #27ae60;
        }

        .share-btn.copied {
            background: rgba(39, 174, 96, 0.15);
            border-color: #27ae60;
            color: #27ae60;
        }

        .share-btn svg {
            width: 14px;
            height: 14px;
            fill: currentColor;
        }

        @media (max-width: 900px) {
            .main-layout {
                flex-direction: column;
            }

            .left-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
            }

            .controls {
                flex-direction: row;
                flex-wrap: wrap;
                flex: 1;
            }

            .city-selector {
                flex: 1;
                min-width: 200px;
            }

            .chart-type-selector {
                width: 100%;
            }
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.4rem;
            }

            .left-panel {
                flex-direction: column;
            }

            .controls {
                flex-direction: column;
            }

            .city-selector {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>City Weather Explorer</h1>
            <p class="subtitle">3D comparison of monthly weather patterns</p>
            <button class="share-btn" id="shareBtn">
                <svg viewBox="0 0 24 24"><path d="M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92z"/></svg>
                <span id="shareBtnText">Share</span>
            </button>
        </header>

        <div class="main-layout">
            <div class="left-panel">
                <div class="toggle-row">
                    <div class="theme-toggle">
                        <span>Dark Mode</span>
                        <div class="toggle-switch" id="themeToggle"></div>
                    </div>
                    <div class="theme-toggle">
                        <span id="unitLabel">°F</span>
                        <div class="toggle-switch" id="unitToggle"></div>
                    </div>
                </div>

                <div class="chart-type-selector">
                    <label>Data Type</label>
                    <div class="toggle-group" id="dataTypeToggle">
                        <button class="toggle-btn active" data-value="temperature">Temperature</button>
                        <button class="toggle-btn" data-value="rainfall">Rainfall</button>
                        <button class="toggle-btn" data-value="sunlight">Sunlight</button>
                    </div>
                </div>

                <div class="chart-type-selector" id="tempTypeSelector">
                    <label>Temperature Type</label>
                    <div class="toggle-group" id="tempTypeToggle">
                        <button class="toggle-btn active" data-value="actual">Average</button>
                        <button class="toggle-btn" data-value="feels">Feels Like</button>
                    </div>
                    <div class="toggle-group" id="tempMetricToggle">
                        <button class="toggle-btn active" data-value="high">High</button>
                        <button class="toggle-btn" data-value="avg">Mean</button>
                        <button class="toggle-btn" data-value="low">Low</button>
                    </div>
                </div>

                <div class="controls">
                    <div class="city-selector">
                        <label><span class="color-indicator" style="background: #e67e22;"></span>City 1</label>
                        <div class="search-container">
                            <input type="text" class="city-input" id="search1" placeholder="Search for a city..." autocomplete="off">
                            <div class="autocomplete-dropdown" id="dropdown1"></div>
                        </div>
                        <div class="decade-selector">
                            <label>Decade</label>
                            <select class="decade-select" id="decade1"></select>
                        </div>
                        <div id="selected1"></div>
                        <div id="loading1"></div>
                        <div id="error1"></div>
                    </div>
                    <div class="city-selector">
                        <label><span class="color-indicator" style="background: #27ae60;"></span>City 2</label>
                        <div class="search-container">
                            <input type="text" class="city-input" id="search2" placeholder="Search for a city..." autocomplete="off">
                            <div class="autocomplete-dropdown" id="dropdown2"></div>
                        </div>
                        <div class="decade-selector">
                            <label>Decade</label>
                            <select class="decade-select" id="decade2"></select>
                        </div>
                        <div id="selected2"></div>
                        <div id="loading2"></div>
                        <div id="error2"></div>
                    </div>
                    <div class="city-selector">
                        <label><span class="color-indicator" style="background: #9b59b6;"></span>City 3</label>
                        <div class="search-container">
                            <input type="text" class="city-input" id="search3" placeholder="Search for a city..." autocomplete="off">
                            <div class="autocomplete-dropdown" id="dropdown3"></div>
                        </div>
                        <div class="decade-selector">
                            <label>Decade</label>
                            <select class="decade-select" id="decade3"></select>
                        </div>
                        <div id="selected3"></div>
                        <div id="loading3"></div>
                        <div id="error3"></div>
                    </div>
                </div>

                <p class="instructions">Drag to rotate the 3D plot</p>
            </div>

            <div class="right-panel">
                <div class="chart-container">
                    <div class="chart-card active" id="highCard">
                        <div class="chart-wrapper" id="highChartWrapper">
                            <div class="no-data-message" id="noDataHigh">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="avgCard">
                        <div class="chart-wrapper" id="avgChartWrapper">
                            <div class="no-data-message" id="noDataAvg">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="lowCard">
                        <div class="chart-wrapper" id="lowChartWrapper">
                            <div class="no-data-message" id="noDataLow">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="feelsHighCard">
                        <div class="chart-wrapper" id="feelsHighChartWrapper">
                            <div class="no-data-message" id="noDataFeelsHigh">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="feelsAvgCard">
                        <div class="chart-wrapper" id="feelsAvgChartWrapper">
                            <div class="no-data-message" id="noDataFeelsAvg">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="feelsLowCard">
                        <div class="chart-wrapper" id="feelsLowChartWrapper">
                            <div class="no-data-message" id="noDataFeelsLow">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="rainfallCard">
                        <div class="chart-wrapper" id="rainfallChartWrapper">
                            <div class="no-data-message" id="noDataRainfall">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="chart-card" id="sunlightCard">
                        <div class="chart-wrapper" id="sunlightChartWrapper">
                            <div class="no-data-message" id="noDataSunlight">Select cities to compare</div>
                        </div>
                    </div>
                    <div class="legend-container">
                        <div class="legend-item" id="legend1">
                            <div class="legend-color" style="background: #e67e22;"></div>
                            <span class="legend-text" id="legendText1">City 1</span>
                        </div>
                        <div class="legend-item" id="legend2">
                            <div class="legend-color" style="background: #27ae60;"></div>
                            <span class="legend-text" id="legendText2">City 2</span>
                        </div>
                        <div class="legend-item" id="legend3">
                            <div class="legend-color" style="background: #9b59b6;"></div>
                            <span class="legend-text" id="legendText3">City 3</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <footer>
            <p>Data from <a href="https://open-meteo.com/" target="_blank">Open-Meteo API</a> | Heights represent <span id="footerUnit">°F</span></p>
        </footer>
    </div>

    <script>
        // Constants
        const MONTHS = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
        const COLORS = [
            { hex: 0xe67e22, css: '#e67e22' },  // Orange
            { hex: 0x27ae60, css: '#27ae60' },  // Green
            { hex: 0x9b59b6, css: '#9b59b6' }   // Purple
        ];
        const FADE_SPEED = 0.15;
        const BASE_RADIUS = 3.2;
        const RADIUS_OFFSET = 0.35;
        const MIN_HEIGHT = 1.0;
        const MAX_HEIGHT = 5.0;

        // Generate decades from 1940s to current decade
        const DECADES = (() => {
            const currentYear = new Date().getFullYear();
            const currentDecade = Math.floor(currentYear / 10) * 10;
            const decades = [];
            for (let year = 1940; year <= currentDecade; year += 10) {
                decades.push({
                    value: year,
                    label: `${year}s`,
                    startYear: year,
                    endYear: Math.min(year + 9, currentYear)
                });
            }
            return decades.reverse(); // Most recent first
        })();

        // State
        const selectedCities = [null, null, null];
        const selectedDecades = [DECADES[0].value, DECADES[0].value, DECADES[0].value]; // Default to current decade
        let searchTimeouts = [null, null, null];
        let isDarkMode = false;
        let useCelsius = false;
        let hoveredCityIndex = -1;
        let isSyncing = false;
        let tempType = 'actual'; // 'actual' or 'feels'
        let tempMetric = 'high'; // 'high', 'avg', or 'low'
        let dataType = 'temperature'; // 'temperature' or 'rainfall'

        // Get chart type key from current selections
        function getChartTypeKey() {
            if (dataType === 'rainfall') {
                return 'rainfall';
            }
            if (dataType === 'sunlight') {
                return 'sunlight';
            }
            if (tempType === 'actual') {
                return tempMetric; // 'high', 'avg', or 'low'
            } else {
                // 'feels' + capitalize metric
                const capitalized = tempMetric.charAt(0).toUpperCase() + tempMetric.slice(1);
                return 'feels' + capitalized; // 'feelsHigh', 'feelsAvg', or 'feelsLow'
            }
        }

        function updateTempTypeToggle() {
            const chartType = getChartTypeKey();
            switchChart(chartType);
        }

        function toggleTheme() {
            isDarkMode = !isDarkMode;
            document.documentElement.setAttribute('data-theme', isDarkMode ? 'dark' : 'light');
            localStorage.setItem('theme', isDarkMode ? 'dark' : 'light');
            document.getElementById('themeToggle').classList.toggle('active', isDarkMode);
            updateSceneColors();
        }

        function loadTheme() {
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                isDarkMode = true;
                document.documentElement.setAttribute('data-theme', 'dark');
                document.getElementById('themeToggle').classList.add('active');
            }
        }

        function updateUnitDisplay() {
            if (dataType === 'rainfall') {
                document.getElementById('unitLabel').textContent = 'mm';
                document.getElementById('footerUnit').textContent = 'mm';
            } else if (dataType === 'sunlight') {
                document.getElementById('unitLabel').textContent = 'hrs';
                document.getElementById('footerUnit').textContent = 'hours';
            } else {
                const unit = useCelsius ? '°C' : '°F';
                document.getElementById('unitLabel').textContent = unit;
                document.getElementById('footerUnit').textContent = unit;
            }
            document.getElementById('unitToggle').classList.toggle('active', useCelsius);
        }

        function toggleUnit() {
            useCelsius = !useCelsius;
            localStorage.setItem('unit', useCelsius ? 'celsius' : 'fahrenheit');
            updateUnitDisplay();
            // Rebuild charts with new unit
            updateCharts();
        }

        function loadUnit() {
            const savedUnit = localStorage.getItem('unit');
            if (savedUnit === 'celsius') {
                useCelsius = true;
                updateUnitDisplay();
            }
        }

        // URL State Management
        function encodeStateToURL() {
            const params = new URLSearchParams();

            // Encode settings
            params.set('dataType', dataType);
            params.set('tempType', tempType);
            params.set('tempMetric', tempMetric);
            if (useCelsius) params.set('unit', 'c');
            if (isDarkMode) params.set('theme', 'dark');

            // Encode cities
            selectedCities.forEach((city, i) => {
                if (city) {
                    params.set(`c${i}`, `${city.name}|${city.latitude}|${city.longitude}|${city.country || ''}|${city.admin1 || ''}`);
                    params.set(`d${i}`, selectedDecades[i]);
                }
            });

            return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
        }

        async function decodeStateFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.size === 0) return false;

            // Decode settings
            if (params.has('dataType')) {
                dataType = params.get('dataType');
                document.querySelectorAll('#dataTypeToggle .toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === dataType);
                });
                const tempTypeSelector = document.getElementById('tempTypeSelector');
                tempTypeSelector.style.display = dataType === 'temperature' ? 'block' : 'none';
                const unitToggleContainer = document.getElementById('unitToggle').parentElement;
                unitToggleContainer.style.display = dataType === 'temperature' ? 'flex' : 'none';
            }

            if (params.has('tempType')) {
                tempType = params.get('tempType');
                document.querySelectorAll('#tempTypeToggle .toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === tempType);
                });
            }

            if (params.has('tempMetric')) {
                tempMetric = params.get('tempMetric');
                document.querySelectorAll('#tempMetricToggle .toggle-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.value === tempMetric);
                });
            }

            if (params.get('unit') === 'c') {
                useCelsius = true;
                updateUnitDisplay();
            }

            if (params.get('theme') === 'dark' && !isDarkMode) {
                toggleTheme();
            }

            // Switch to correct chart
            updateTempTypeToggle();

            // Decode and load cities
            const citiesToLoad = [];
            for (let i = 0; i < 3; i++) {
                const cityParam = params.get(`c${i}`);
                const decadeParam = params.get(`d${i}`);

                if (cityParam) {
                    const [name, lat, lon, country, admin1] = cityParam.split('|');
                    const decade = decadeParam ? parseInt(decadeParam) : DECADES[0].value;

                    // Update decade selector
                    selectedDecades[i] = decade;
                    const decadeSelect = document.getElementById(`decade${i + 1}`);
                    if (decadeSelect) decadeSelect.value = decade;

                    citiesToLoad.push({
                        index: i,
                        city: {
                            name,
                            latitude: parseFloat(lat),
                            longitude: parseFloat(lon),
                            country: country || undefined,
                            admin1: admin1 || undefined
                        }
                    });
                }
            }

            // Load cities sequentially to avoid rate limiting
            for (const { index, city } of citiesToLoad) {
                await loadCityFromURL(city, index);
            }

            return citiesToLoad.length > 0;
        }

        async function loadCityFromURL(city, index) {
            const loadingDiv = document.getElementById(`loading${index + 1}`);
            const errorDiv = document.getElementById(`error${index + 1}`);
            const decade = selectedDecades[index];

            errorDiv.innerHTML = '';
            loadingDiv.innerHTML = `<div class="loading-indicator"><div class="spinner"></div>Loading ${city.name}...</div>`;

            try {
                const tempData = await fetchTemperatureData(city.latitude, city.longitude, decade);

                selectedCities[index] = {
                    name: city.name,
                    country: city.country,
                    admin1: city.admin1,
                    latitude: city.latitude,
                    longitude: city.longitude,
                    decade: decade,
                    ...tempData
                };

                loadingDiv.innerHTML = '';
                renderSelectedCity(index);
                updateCharts();
            } catch (error) {
                loadingDiv.innerHTML = '';
                errorDiv.innerHTML = `<div class="error-message">Failed to load ${city.name}. Please try again.</div>`;
            }
        }

        async function shareCurrentState() {
            const url = encodeStateToURL();
            const shareBtn = document.getElementById('shareBtn');
            const shareBtnText = document.getElementById('shareBtnText');

            try {
                await navigator.clipboard.writeText(url);
                shareBtn.classList.add('copied');
                shareBtnText.textContent = 'Copied!';

                // Also update URL bar without reloading
                window.history.replaceState({}, '', url);

                setTimeout(() => {
                    shareBtn.classList.remove('copied');
                    shareBtnText.textContent = 'Share';
                }, 2000);
            } catch (err) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);

                shareBtn.classList.add('copied');
                shareBtnText.textContent = 'Copied!';
                window.history.replaceState({}, '', url);

                setTimeout(() => {
                    shareBtn.classList.remove('copied');
                    shareBtnText.textContent = 'Share';
                }, 2000);
            }
        }

        function convertTemp(fahrenheit) {
            if (useCelsius) {
                return Math.round((fahrenheit - 32) * 5 / 9);
            }
            return fahrenheit;
        }

        // Three.js objects
        const scenes = {};
        const cameras = {};
        const renderers = {};
        const controls = {};
        const CHART_TYPES = ['high', 'low', 'avg', 'feelsHigh', 'feelsLow', 'feelsAvg', 'rainfall', 'sunlight'];
        const cityMeshes = { high: [], low: [], avg: [], feelsHigh: [], feelsLow: [], feelsAvg: [], rainfall: [], sunlight: [] };
        const temperatureLabels = { high: [], low: [], avg: [], feelsHigh: [], feelsLow: [], feelsAvg: [], rainfall: [], sunlight: [] };

        function switchChart(chartType) {
            // Hide all chart cards
            CHART_TYPES.forEach(key => {
                document.getElementById(key + 'Card').classList.remove('active');
            });

            // Show selected chart card
            document.getElementById(chartType + 'Card').classList.add('active');

            // Trigger resize to ensure canvas fills container
            setTimeout(() => handleResize(), 10);
        }

        function init3DScene(containerId, sceneKey) {
            const container = document.getElementById(containerId);
            const width = container.clientWidth;
            const height = container.clientHeight;

            // Scene
            const scene = new THREE.Scene();
            scenes[sceneKey] = scene;

            // Camera - positioned to see full object with focus point lower
            const camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(9, 5, 9);
            cameras[sceneKey] = camera;

            // Renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(width, height);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);
            renderers[sceneKey] = renderer;

            // Controls - only horizontal rotation (carousel spin)
            const orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
            orbitControls.target.set(0, 2, 0);
            orbitControls.enableDamping = true;
            orbitControls.dampingFactor = 0.05;
            orbitControls.enablePan = false;
            orbitControls.enableZoom = false;
            orbitControls.minPolarAngle = Math.PI / 2.5;
            orbitControls.maxPolarAngle = Math.PI / 2.5;
            orbitControls.update();
            controls[sceneKey] = orbitControls;

            // Sync rotation with other charts
            orbitControls.addEventListener('change', () => {
                if (isSyncing) return;
                isSyncing = true;
                syncRotation(sceneKey);
                isSyncing = false;
            });

            // Soft, diffuse lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight.position.set(5, 10, 5);
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.3);
            directionalLight2.position.set(-5, 8, -5);
            scene.add(directionalLight2);

            const directionalLight3 = new THREE.DirectionalLight(0xffffff, 0.2);
            directionalLight3.position.set(0, -5, 0);
            scene.add(directionalLight3);

            // Base platform
            createBasePlatform(scene);

            // Month labels
            createMonthLabels(scene);
        }

        function syncRotation(sourceKey) {
            const sourceCamera = cameras[sourceKey];
            const sourceControls = controls[sourceKey];
            if (!sourceCamera || !sourceControls) return;

            CHART_TYPES.filter(k => k !== sourceKey).forEach(key => {
                if (cameras[key] && controls[key]) {
                    cameras[key].position.copy(sourceCamera.position);
                    controls[key].update();
                }
            });
        }

        function updateSceneColors() {
            // Update renderer clear color and rebuild base platforms
            CHART_TYPES.forEach(key => {
                if (scenes[key]) {
                    // Remove old base platform elements (wedges, lines, ring, month labels)
                    const toRemove = [];
                    scenes[key].children.forEach(child => {
                        if (child.type === 'Mesh' || child.type === 'Line' || child.type === 'Sprite') {
                            // Keep city data meshes (they're in groups)
                            if (child.type !== 'Group') {
                                toRemove.push(child);
                            }
                        }
                    });
                    toRemove.forEach(obj => scenes[key].remove(obj));

                    // Rebuild base platform and labels with new colors
                    createBasePlatform(scenes[key]);
                    createMonthLabels(scenes[key]);
                }
            });
        }

        function createBasePlatform(scene) {
            // Relative sunlight hours by month (northern hemisphere)
            // 0 = least sunlight (dark), 1 = most sunlight (light)
            const sunlight = [
                0.15,  // Jan
                0.25,  // Feb
                0.45,  // Mar
                0.65,  // Apr
                0.85,  // May
                1.0,   // Jun
                0.95,  // Jul
                0.80,  // Aug
                0.55,  // Sep
                0.35,  // Oct
                0.20,  // Nov
                0.10   // Dec
            ];

            const radius = 4;

            // Create 12 wedge segments with gradient based on theme
            for (let i = 0; i < 12; i++) {
                const angle1 = (i / 12) * Math.PI * 2 - Math.PI / 2;
                const angle2 = ((i + 1) / 12) * Math.PI * 2 - Math.PI / 2;

                // Create wedge using vertices directly in world XZ plane
                const geometry = new THREE.BufferGeometry();
                const segments = 12;
                const vertices = [0, 0.01, 0]; // center point

                for (let j = 0; j <= segments; j++) {
                    const a = angle1 + (angle2 - angle1) * (j / segments);
                    vertices.push(Math.sin(a) * radius, 0.01, Math.cos(a) * radius);
                }

                const indices = [];
                for (let j = 0; j < segments; j++) {
                    indices.push(0, j + 1, j + 2);
                }

                geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
                geometry.setIndex(indices);

                // Theme-aware gradient
                let brightness;
                if (isDarkMode) {
                    // Dark mode: darker base with subtle variation
                    brightness = Math.round(30 + sunlight[i] * 40);
                } else {
                    // Light mode: white for most sunlight, darker gray for least
                    brightness = Math.round(180 + sunlight[i] * 70);
                }
                const color = (brightness << 16) + (brightness << 8) + brightness;

                const material = new THREE.MeshBasicMaterial({
                    color: color,
                    side: THREE.DoubleSide
                });

                const wedge = new THREE.Mesh(geometry, material);
                scene.add(wedge);
            }

            // Draw lines from center to each month
            const lineColor = isDarkMode ? 0x555555 : 0x999999;
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;

                const points = [
                    new THREE.Vector3(0, 0.02, 0),
                    new THREE.Vector3(x, 0.02, z)
                ];
                const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                const lineMaterial = new THREE.LineBasicMaterial({
                    color: lineColor,
                    transparent: true,
                    opacity: 0.6
                });
                const line = new THREE.Line(lineGeometry, lineMaterial);
                scene.add(line);
            }

            // Subtle outer ring
            const ringGeometry = new THREE.RingGeometry(3.95, 4, 64);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: isDarkMode ? 0x444444 : 0x888888,
                transparent: true,
                opacity: 0.5,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.rotation.x = -Math.PI / 2;
            ring.position.y = 0.02;
            scene.add(ring);
        }

        function createMonthLabels(scene) {
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                const radius = 4.3;
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;

                const canvas = document.createElement('canvas');
                canvas.width = 100;
                canvas.height = 50;
                const ctx = canvas.getContext('2d');
                ctx.fillStyle = isDarkMode ? '#aaaaaa' : '#555555';
                ctx.font = 'bold 28px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(MONTHS[i], 50, 25);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(x, 0.15, z);
                sprite.scale.set(1, 0.5, 1);
                scene.add(sprite);
            }
        }

        function createTemperatureLabel(tempF, color, position, dataTypeKey = 'temperature') {
            let displayValue, suffix;
            if (dataTypeKey === 'rainfall') {
                displayValue = tempF; // Already in mm
                suffix = 'mm';
            } else if (dataTypeKey === 'sunlight') {
                displayValue = tempF; // Already in hours
                suffix = 'h';
            } else {
                displayValue = convertTemp(tempF);
                suffix = '°';
            }

            const canvas = document.createElement('canvas');
            canvas.width = 96;
            canvas.height = 48;
            const ctx = canvas.getContext('2d');

            // Background pill - theme aware
            ctx.fillStyle = isDarkMode ? 'rgba(22, 33, 62, 0.9)' : 'rgba(255, 255, 255, 0.9)';
            ctx.beginPath();
            ctx.roundRect(8, 8, 80, 32, 12);
            ctx.fill();
            ctx.strokeStyle = isDarkMode ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Text
            ctx.fillStyle = color;
            ctx.font = 'bold 22px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(`${displayValue}${suffix}`, 48, 24);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthWrite: false,
                depthTest: false
            });
            const sprite = new THREE.Sprite(spriteMaterial);
            sprite.renderOrder = 999; // Ensure labels render last
            sprite.position.copy(position);
            sprite.position.y += 0.5;
            sprite.scale.set(0.8, 0.4, 1);
            return sprite;
        }

        function create3DRadarShape(scene, data, colorIndex, sceneKey, minVal, maxVal) {
            const color = COLORS[colorIndex];
            const radius = BASE_RADIUS + colorIndex * RADIUS_OFFSET;
            const range = maxVal - minVal || 1;
            const points = [];
            const dataTypeKey = sceneKey === 'rainfall' ? 'rainfall' : (sceneKey === 'sunlight' ? 'sunlight' : 'temperature');

            // Create points for the shape
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2 - Math.PI / 2;
                const x = Math.sin(angle) * radius;
                const z = Math.cos(angle) * radius;
                const normalized = (data[i] - minVal) / range;
                const y = MIN_HEIGHT + normalized * (MAX_HEIGHT - MIN_HEIGHT);
                points.push(new THREE.Vector3(x, y, z));
            }

            const group = new THREE.Group();
            const labels = [];

            // Spheres and labels at each month - soft matte style
            for (let i = 0; i < 12; i++) {
                const sphereGeometry = new THREE.SphereGeometry(0.16, 24, 24);
                const sphereMaterial = new THREE.MeshLambertMaterial({
                    color: color.hex,
                    transparent: true,
                    opacity: 0.85
                });
                const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
                sphere.position.set(points[i].x, points[i].y, points[i].z);
                group.add(sphere);

                // Value label (temperature, rainfall, or sunlight)
                const label = createTemperatureLabel(data[i], color.css, points[i], dataTypeKey);
                label.userData.monthIndex = i;
                label.userData.basePosition = points[i].clone();
                labels.push(label);
                group.add(label);
            }

            // Store labels for this city in the scene
            temperatureLabels[sceneKey].push(...labels);

            // Connect with a smooth, soft tube
            const curvePoints = [...points, points[0]];
            const curve = new THREE.CatmullRomCurve3(curvePoints);
            const tubeGeometry = new THREE.TubeGeometry(curve, 72, 0.06, 12, true);
            const tubeMaterial = new THREE.MeshLambertMaterial({
                color: color.hex,
                transparent: true,
                opacity: 0.75
            });
            const tube = new THREE.Mesh(tubeGeometry, tubeMaterial);
            group.add(tube);

            scene.add(group);
            return group;
        }

        function clearCityMeshes(sceneKey) {
            cityMeshes[sceneKey].forEach(mesh => {
                scenes[sceneKey].remove(mesh);
            });
            cityMeshes[sceneKey] = [];
            temperatureLabels[sceneKey] = [];
        }

        function updateCharts() {
            const activeCities = selectedCities.filter(c => c !== null);
            const hasData = activeCities.length > 0;

            // Toggle no-data messages
            document.getElementById('noDataHigh').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataLow').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataAvg').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataFeelsHigh').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataFeelsLow').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataFeelsAvg').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataRainfall').style.display = hasData ? 'none' : 'block';
            document.getElementById('noDataSunlight').style.display = hasData ? 'none' : 'block';

            // Update legend
            for (let i = 0; i < 3; i++) {
                const legendItem = document.getElementById(`legend${i + 1}`);
                const legendText = document.getElementById(`legendText${i + 1}`);
                if (selectedCities[i]) {
                    const city = selectedCities[i];
                    const decadeLabel = city.decade ? ` (${city.decade}s)` : '';
                    legendItem.classList.add('visible');
                    legendText.textContent = city.name + decadeLabel;
                } else {
                    legendItem.classList.remove('visible');
                }
            }

            // Clear existing meshes
            CHART_TYPES.forEach(key => clearCityMeshes(key));

            // Calculate min/max for each chart type across all selected cities
            const getMinMax = (key) => {
                const allValues = activeCities.flatMap(city => city[key]);
                return {
                    min: Math.min(...allValues),
                    max: Math.max(...allValues)
                };
            };

            const ranges = {};
            CHART_TYPES.forEach(key => {
                ranges[key] = activeCities.length ? getMinMax(key) : { min: 0, max: 100 };
            });

            // Add new city data with normalized heights
            selectedCities.forEach((city, i) => {
                if (!city) return;

                CHART_TYPES.forEach(key => {
                    const mesh = create3DRadarShape(scenes[key], city[key], i, key, ranges[key].min, ranges[key].max);
                    cityMeshes[key].push(mesh);
                });
            });
        }

        function setHoveredCity(cityIndex) {
            hoveredCityIndex = cityIndex;
            CHART_TYPES.forEach(key => updateRingOpacity(key));
        }

        function updateRingOpacity(sceneKey) {
            const meshes = cityMeshes[sceneKey];
            const labels = temperatureLabels[sceneKey];
            const hovered = hoveredCityIndex;

            meshes.forEach((group, cityIndex) => {
                const isHovered = hovered === -1 || hovered === cityIndex;

                // Set target opacities on meshes
                group.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if (child.geometry.type === 'SphereGeometry') {
                            child.userData.targetOpacity = isHovered ? 0.85 : 0.1;
                        } else if (child.geometry.type === 'TubeGeometry') {
                            child.userData.targetOpacity = isHovered ? 0.75 : 0.1;
                        }
                    }
                });
            });

            // Update label target visibility based on hover
            const labelsPerCity = 12;
            labels.forEach((label, index) => {
                const cityIndex = Math.floor(index / labelsPerCity);
                const isHovered = hovered === -1 || hovered === cityIndex;
                label.userData.targetHoverOpacity = isHovered ? 1 : 0.2;
            });
        }

        function animateOpacities(sceneKey) {
            const meshes = cityMeshes[sceneKey];
            const labels = temperatureLabels[sceneKey];

            // Animate mesh opacities
            meshes.forEach((group) => {
                group.traverse((child) => {
                    if (child.isMesh && child.material && child.userData.targetOpacity !== undefined) {
                        const current = child.material.opacity;
                        const target = child.userData.targetOpacity;
                        if (Math.abs(current - target) > 0.01) {
                            child.material.opacity += (target - current) * FADE_SPEED;
                        } else {
                            child.material.opacity = target;
                        }
                    }
                });
            });

            // Animate label hover opacities
            labels.forEach((label) => {
                if (label.userData.targetHoverOpacity === undefined) {
                    label.userData.targetHoverOpacity = 1;
                }
                if (label.userData.currentHoverOpacity === undefined) {
                    label.userData.currentHoverOpacity = 1;
                }
                const current = label.userData.currentHoverOpacity;
                const target = label.userData.targetHoverOpacity;
                if (Math.abs(current - target) > 0.01) {
                    label.userData.currentHoverOpacity += (target - current) * FADE_SPEED;
                } else {
                    label.userData.currentHoverOpacity = target;
                }
            });
        }

        function updateLabelVisibility(sceneKey) {
            const camera = cameras[sceneKey];
            const labels = temperatureLabels[sceneKey];
            if (!camera || !labels.length) return;

            // Get camera direction in XZ plane (ignore Y)
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            cameraDir.y = 0;
            cameraDir.normalize();

            labels.forEach(label => {
                // Get label position in XZ plane
                const labelPos = label.userData.basePosition.clone();
                labelPos.y = 0;
                labelPos.normalize();

                // Dot product: -1 = facing camera, 1 = facing away
                const dot = labelPos.dot(cameraDir);

                // Smooth gradient across the full range
                // Map dot from [-1, 1] to opacity [1, 0] with a curve
                // Use a power curve to keep labels more visible longer
                const normalized = (dot + 1) / 2; // Map to [0, 1] where 0=facing, 1=away
                const opacity = Math.pow(1 - normalized, 1.5); // Power curve for smoother falloff

                // Apply hover opacity multiplier
                const hoverOpacity = label.userData.currentHoverOpacity !== undefined ? label.userData.currentHoverOpacity : 1;
                const finalOpacity = opacity * hoverOpacity;

                // Hide completely when fully transparent to prevent occlusion
                label.visible = finalOpacity > 0.01;
                label.material.opacity = finalOpacity;
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            CHART_TYPES.forEach(key => {
                if (controls[key]) controls[key].update();
                animateOpacities(key);
                updateLabelVisibility(key);
                if (renderers[key] && scenes[key] && cameras[key]) {
                    renderers[key].render(scenes[key], cameras[key]);
                }
            });
        }

        function handleResize() {
            CHART_TYPES.forEach(key => {
                const wrapperId = key + 'ChartWrapper';
                const container = document.getElementById(wrapperId);
                if (!container || !cameras[key] || !renderers[key]) return;

                const width = container.clientWidth;
                const height = container.clientHeight;

                cameras[key].aspect = width / height;
                cameras[key].updateProjectionMatrix();
                renderers[key].setSize(width, height);
            });
        }

        // API Functions
        async function searchCities(query) {
            if (query.length < 2) return [];
            const url = `https://customer-geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(query)}&count=8&language=en&apikey=${API_KEY}`;
            try {
                const response = await fetch(url);
                const data = await response.json();
                return data.results || [];
            } catch (error) {
                console.error('Geocoding error:', error);
                return [];
            }
        }

        // API configuration
        const API_KEY = 'jRY0E02cPjYbgBSW';

        // Cache functions
        const CACHE_PREFIX = 'weather_cache_';
        const CACHE_VERSION = 'v4_'; // Updated to v4 for sunlight hours

        function getCacheKey(lat, lon, decade) {
            // Round coordinates to 2 decimal places to handle minor variations
            const roundedLat = Math.round(lat * 100) / 100;
            const roundedLon = Math.round(lon * 100) / 100;
            return `${CACHE_PREFIX}${CACHE_VERSION}${roundedLat}_${roundedLon}_${decade}`;
        }

        function getFromCache(lat, lon, decade) {
            try {
                const key = getCacheKey(lat, lon, decade);
                const cached = localStorage.getItem(key);
                if (cached) {
                    return JSON.parse(cached);
                }
            } catch (e) {
                console.warn('Cache read error:', e);
            }
            return null;
        }

        function saveToCache(lat, lon, decade, data) {
            try {
                const key = getCacheKey(lat, lon, decade);
                localStorage.setItem(key, JSON.stringify(data));
            } catch (e) {
                console.warn('Cache write error:', e);
                // If localStorage is full, clear old cache entries
                if (e.name === 'QuotaExceededError') {
                    clearOldCache();
                }
            }
        }

        function clearOldCache() {
            try {
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith(CACHE_PREFIX)) {
                        keysToRemove.push(key);
                    }
                }
                // Remove half of cached entries
                keysToRemove.slice(0, Math.ceil(keysToRemove.length / 2)).forEach(key => {
                    localStorage.removeItem(key);
                });
            } catch (e) {
                console.warn('Cache clear error:', e);
            }
        }

        // Retry with exponential backoff
        async function fetchWithRetry(url, maxRetries = 3) {
            let lastError;
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const response = await fetch(url);
                    if (response.status === 429) {
                        // Too many requests - wait and retry
                        const waitTime = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        console.log(`Rate limited. Retrying in ${Math.round(waitTime / 1000)}s...`);
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        continue;
                    }
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return await response.json();
                } catch (error) {
                    lastError = error;
                    if (attempt < maxRetries - 1) {
                        const waitTime = Math.pow(2, attempt) * 1000;
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                    }
                }
            }
            throw lastError;
        }

        async function fetchTemperatureData(lat, lon, decadeStartYear) {
            // Check cache first
            const cached = getFromCache(lat, lon, decadeStartYear);
            if (cached) {
                console.log('Using cached data for', lat, lon, decadeStartYear);
                return cached;
            }

            // Find the decade info
            const decade = DECADES.find(d => d.value === decadeStartYear) || DECADES[0];
            const currentYear = new Date().getFullYear();

            // For current decade, end 7 days ago; for past decades, use full decade
            let startDate, endDate;
            if (decade.endYear >= currentYear) {
                // Current decade - end 7 days before today
                endDate = new Date();
                endDate.setDate(endDate.getDate() - 7);
                startDate = new Date(decade.startYear, 0, 1);
            } else {
                // Past decade - use full decade range
                startDate = new Date(decade.startYear, 0, 1);
                endDate = new Date(decade.endYear, 11, 31);
            }

            const formatDate = d => d.toISOString().split('T')[0];
            const url = `https://customer-archive-api.open-meteo.com/v1/archive?latitude=${lat}&longitude=${lon}&start_date=${formatDate(startDate)}&end_date=${formatDate(endDate)}&daily=temperature_2m_max,temperature_2m_min,temperature_2m_mean,apparent_temperature_max,apparent_temperature_min,apparent_temperature_mean,precipitation_sum,sunshine_duration&timezone=auto&apikey=${API_KEY}`;

            try {
                const data = await fetchWithRetry(url);
                const result = calculateMonthlyAverages(data);
                // Save to cache
                saveToCache(lat, lon, decadeStartYear, result);
                return result;
            } catch (error) {
                console.error('Weather API error:', error);
                throw error;
            }
        }

        function calculateMonthlyAverages(data) {
            const monthlyData = {
                high: Array(12).fill(null).map(() => []),
                low: Array(12).fill(null).map(() => []),
                avg: Array(12).fill(null).map(() => []),
                feelsHigh: Array(12).fill(null).map(() => []),
                feelsLow: Array(12).fill(null).map(() => []),
                feelsAvg: Array(12).fill(null).map(() => []),
                sunlight: Array(12).fill(null).map(() => [])
            };

            // For rainfall, we need to track by year-month to sum monthly totals first
            const rainfallByYearMonth = {}; // { "2020-0": sum, "2020-1": sum, ... }

            const dates = data.daily.time;
            const highs = data.daily.temperature_2m_max;
            const lows = data.daily.temperature_2m_min;
            const avgs = data.daily.temperature_2m_mean;
            const feelsHighs = data.daily.apparent_temperature_max;
            const feelsLows = data.daily.apparent_temperature_min;
            const feelsAvgs = data.daily.apparent_temperature_mean;
            const precipitation = data.daily.precipitation_sum;
            const sunshine = data.daily.sunshine_duration;

            for (let i = 0; i < dates.length; i++) {
                const date = new Date(dates[i]);
                const month = date.getMonth();
                const year = date.getFullYear();

                if (highs[i] !== null) monthlyData.high[month].push(highs[i]);
                if (lows[i] !== null) monthlyData.low[month].push(lows[i]);
                if (avgs[i] !== null) monthlyData.avg[month].push(avgs[i]);
                if (feelsHighs[i] !== null) monthlyData.feelsHigh[month].push(feelsHighs[i]);
                if (feelsLows[i] !== null) monthlyData.feelsLow[month].push(feelsLows[i]);
                if (feelsAvgs[i] !== null) monthlyData.feelsAvg[month].push(feelsAvgs[i]);
                // Sunlight: convert seconds to hours for daily average
                if (sunshine && sunshine[i] !== null) monthlyData.sunlight[month].push(sunshine[i] / 3600);

                // Sum rainfall by year-month
                if (precipitation && precipitation[i] !== null) {
                    const key = `${year}-${month}`;
                    rainfallByYearMonth[key] = (rainfallByYearMonth[key] || 0) + precipitation[i];
                }
            }

            // Convert year-month rainfall sums to monthly averages
            const monthlyRainfallTotals = Array(12).fill(null).map(() => []);
            for (const [key, sum] of Object.entries(rainfallByYearMonth)) {
                const month = parseInt(key.split('-')[1]);
                monthlyRainfallTotals[month].push(sum);
            }

            const toFahrenheit = c => Math.round((c * 9/5) + 32);
            const average = arr => arr.length ? arr.reduce((a, b) => a + b, 0) / arr.length : 0;

            return {
                high: monthlyData.high.map(arr => toFahrenheit(average(arr))),
                low: monthlyData.low.map(arr => toFahrenheit(average(arr))),
                avg: monthlyData.avg.map(arr => toFahrenheit(average(arr))),
                feelsHigh: monthlyData.feelsHigh.map(arr => toFahrenheit(average(arr))),
                feelsLow: monthlyData.feelsLow.map(arr => toFahrenheit(average(arr))),
                feelsAvg: monthlyData.feelsAvg.map(arr => toFahrenheit(average(arr))),
                rainfall: monthlyRainfallTotals.map(arr => Math.round(average(arr))), // Average total monthly rainfall in mm
                sunlight: monthlyData.sunlight.map(arr => Math.round(average(arr) * 10) / 10) // Average daily sunlight hours (1 decimal)
            };
        }

        function setupSearchInput(index) {
            const input = document.getElementById(`search${index + 1}`);
            const dropdown = document.getElementById(`dropdown${index + 1}`);

            input.addEventListener('input', () => {
                clearTimeout(searchTimeouts[index]);
                const query = input.value.trim();

                if (query.length < 2) {
                    dropdown.classList.remove('show');
                    return;
                }

                searchTimeouts[index] = setTimeout(async () => {
                    const results = await searchCities(query);
                    renderDropdown(dropdown, results, index);
                }, 300);
            });

            input.addEventListener('focus', () => {
                if (dropdown.children.length > 0) {
                    dropdown.classList.add('show');
                }
            });

            document.addEventListener('click', (e) => {
                if (!e.target.closest(`#search${index + 1}`) && !e.target.closest(`#dropdown${index + 1}`)) {
                    dropdown.classList.remove('show');
                }
            });
        }

        function renderDropdown(dropdown, results, index) {
            dropdown.innerHTML = '';

            if (results.length === 0) {
                dropdown.classList.remove('show');
                return;
            }

            results.forEach(city => {
                const item = document.createElement('div');
                item.className = 'autocomplete-item';

                const admin = [city.admin1, city.country].filter(Boolean).join(', ');
                item.innerHTML = `
                    <div class="city-name">${city.name}</div>
                    <div class="city-details">${admin}</div>
                `;

                item.addEventListener('click', () => selectCity(city, index));
                dropdown.appendChild(item);
            });

            dropdown.classList.add('show');
        }

        async function selectCity(city, index) {
            const dropdown = document.getElementById(`dropdown${index + 1}`);
            const input = document.getElementById(`search${index + 1}`);
            const selectedDiv = document.getElementById(`selected${index + 1}`);
            const loadingDiv = document.getElementById(`loading${index + 1}`);
            const errorDiv = document.getElementById(`error${index + 1}`);
            const decade = selectedDecades[index];

            dropdown.classList.remove('show');
            input.value = '';
            errorDiv.innerHTML = '';

            loadingDiv.innerHTML = `<div class="loading-indicator"><div class="spinner"></div>Loading ${decade}s data...</div>`;

            try {
                const tempData = await fetchTemperatureData(city.latitude, city.longitude, decade);

                selectedCities[index] = {
                    name: city.name,
                    country: city.country,
                    admin1: city.admin1,
                    latitude: city.latitude,
                    longitude: city.longitude,
                    decade: decade,
                    ...tempData
                };

                loadingDiv.innerHTML = '';
                renderSelectedCity(index);
                updateCharts();

            } catch (error) {
                loadingDiv.innerHTML = '';
                errorDiv.innerHTML = `<div class="error-message">Failed to load data. Please try again.</div>`;
            }
        }

        async function onDecadeChange(index) {
            const decadeSelect = document.getElementById(`decade${index + 1}`);
            const newDecade = parseInt(decadeSelect.value, 10);
            selectedDecades[index] = newDecade;

            // If a city is already selected, refetch data for the new decade
            const city = selectedCities[index];
            if (city) {
                const loadingDiv = document.getElementById(`loading${index + 1}`);
                const errorDiv = document.getElementById(`error${index + 1}`);
                errorDiv.innerHTML = '';

                loadingDiv.innerHTML = `<div class="loading-indicator"><div class="spinner"></div>Loading ${newDecade}s data...</div>`;

                try {
                    const tempData = await fetchTemperatureData(city.latitude, city.longitude, newDecade);

                    selectedCities[index] = {
                        ...city,
                        decade: newDecade,
                        ...tempData
                    };

                    loadingDiv.innerHTML = '';
                    renderSelectedCity(index);
                    updateCharts();

                } catch (error) {
                    loadingDiv.innerHTML = '';
                    errorDiv.innerHTML = `<div class="error-message">Failed to load data. Please try again.</div>`;
                }
            }
        }

        function renderSelectedCity(index) {
            const selectedDiv = document.getElementById(`selected${index + 1}`);
            const city = selectedCities[index];

            if (!city) {
                selectedDiv.innerHTML = '';
                return;
            }

            const colorClass = index === 0 ? '' : `color-${index + 1}`;
            const location = [city.admin1, city.country].filter(Boolean).join(', ');
            const decadeLabel = city.decade ? `(${city.decade}s)` : '';

            selectedDiv.innerHTML = `
                <div class="selected-city ${colorClass}">
                    <div class="city-info">
                        <span class="name">${city.name} ${decadeLabel}</span>
                        <span class="country">${location}</span>
                    </div>
                    <button class="remove-btn" onclick="removeCity(${index})">&times;</button>
                </div>
            `;
        }

        function removeCity(index) {
            selectedCities[index] = null;
            document.getElementById(`selected${index + 1}`).innerHTML = '';
            document.getElementById(`error${index + 1}`).innerHTML = '';
            updateCharts();
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Load saved theme
            loadTheme();

            // Initialize all chart scenes
            CHART_TYPES.forEach(key => {
                init3DScene(key + 'ChartWrapper', key);
            });

            setupSearchInput(0);
            setupSearchInput(1);
            setupSearchInput(2);

            // Initialize decade dropdowns
            for (let i = 0; i < 3; i++) {
                const decadeSelect = document.getElementById(`decade${i + 1}`);
                DECADES.forEach(decade => {
                    const option = document.createElement('option');
                    option.value = decade.value;
                    option.textContent = decade.label;
                    if (decade.value === selectedDecades[i]) {
                        option.selected = true;
                    }
                    decadeSelect.appendChild(option);
                });
                decadeSelect.addEventListener('change', () => onDecadeChange(i));
            }

            // Data type toggle (Temperature/Rainfall/Sunlight)
            document.querySelectorAll('#dataTypeToggle .toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#dataTypeToggle .toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    dataType = btn.dataset.value;

                    // Show/hide temperature type selector based on data type
                    const tempTypeSelector = document.getElementById('tempTypeSelector');
                    tempTypeSelector.style.display = dataType === 'temperature' ? 'block' : 'none';

                    // Show/hide unit toggle based on data type (no C/F conversion for rainfall or sunlight)
                    const unitToggleContainer = document.getElementById('unitToggle').parentElement;
                    unitToggleContainer.style.display = dataType === 'temperature' ? 'flex' : 'none';

                    // Update unit display
                    updateUnitDisplay();

                    // Switch to appropriate chart
                    updateTempTypeToggle();
                });
            });

            // Temperature type toggles
            document.querySelectorAll('#tempTypeToggle .toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#tempTypeToggle .toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    tempType = btn.dataset.value;
                    updateTempTypeToggle();
                });
            });

            document.querySelectorAll('#tempMetricToggle .toggle-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#tempMetricToggle .toggle-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    tempMetric = btn.dataset.value;
                    updateTempTypeToggle();
                });
            });

            // Theme toggle
            document.getElementById('themeToggle').addEventListener('click', () => {
                toggleTheme();
                // Rebuild city meshes with new label colors
                updateCharts();
            });

            // Unit toggle
            document.getElementById('unitToggle').addEventListener('click', toggleUnit);
            loadUnit();

            // Share button
            document.getElementById('shareBtn').addEventListener('click', shareCurrentState);

            // Legend hover interactions
            for (let i = 0; i < 3; i++) {
                const legendItem = document.getElementById(`legend${i + 1}`);
                legendItem.addEventListener('mouseenter', () => setHoveredCity(i));
                legendItem.addEventListener('mouseleave', () => setHoveredCity(-1));
            }

            window.addEventListener('resize', handleResize);
            animate();

            // Load state from URL if present
            decodeStateFromURL();
        });
    </script>
</body>
</html>
